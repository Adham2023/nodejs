# Functions

"_Subroutins_ or _procedure_"

_function_ bu JavaScript code-blok ya'ni bizning candaydur bir ma'lum ishni bajarishga qaratilgan JS kodimizdir.

_function_ bir marta yozilib hohlagan marta chaqirilishi, qayta-qayta ishlatilishi mumkin: _executed_ or _invoked_

JavaScript _function_lari ko'plab parametrlarini qabul qilishi mumukin: 

_function definition_ ya'ni function yaratilganda o'ziga _parameter_ deb aytiladigan qiymatlarni qabul qilishi mumkin va bu parametrlar ushbu functionsiyaning bodysi yani ushbu function qamrab oluvchi code qismiga _local variable_ ya'ni lokal o'zgaruvchi sifatida ishlatiladi.

_Function invocation_ yoki functionni chaqirishda biz function paramtrlari uchun mos _argumentlar_ berilishi mumkin.

Function-lar odatda ushbu argumentlardan _return value_ yoki function-dan qaytuvchi qiymatnio hisoblashda ishlatishi mumkin.

Argumentlarga qo'shimcha sifatida har bir function chaqirlganda boshqa bir qiymatni ham ko'rishimiz mumkin: _invocation context_ va uning qiymati **_this_** komandasida joylashgan.


**_Agar function qandaydur object propertysiga qiymat sifatida berilgan bo'lsa bu functionga method deb aytiladi_**

Qachonki ushbu function object-da yoki object ichkarisida ishlatilsa ushbu functionning contexti ushbu object-ga teng bo'ladi. yani **_this === obj_**

Function **_constructors_** deb ataladigan objectni ishga tushirish yani yaratadigan qilib tuzilgan.

JavaScript function-lari bu Objectlardur va ular programma tomonidan ishlatilishi mumkin. 

JS functionlarini o'zgaruvchiga qiymat sifatida saqlanishi va ushbu o'zgaruvchni-functionni boshqa bir functionga argument sifatida ishlatish mumkin. JS da functionlar Object ekanligini bilganimiz holda biz unga propertylar set qilsihimiz mumkin, `method`-invoke qilishimiz mumkin.

JavaScript functionlar bir biriniching ichida `nested` qilib ishlatilishi mumkin va o'zlari yaratilgan `scope`dagi harqanday o'zgaruvchilardan foydalanishlari mumkin.

Bu JS Functionlari `Closure` ekanliklarini anglatadi. va Bu juda ham kuchli programming-techniques sanaladi.

## Defining Functions

JS-da functionning yaratishning eng birinchi usulu bu `function` keywordidan foydalangan holda amalga oshirilishi mumkin. 

ES6 JS-versiyasida `function` keywordsiz ham function hosil qilishimiz mumkin: yani **"arrow functions"** deb aytiladi. va o'zining syntaxiga ega va boshqa bir functionga argument sifatida beriladigan vaziyatlarda ishlatiladi.



### Function Declarations

JS-da function declaration quydagicha bo'lishi mumkin: 

`function` keywordidan keyin:

- FUnctionning nomi

- Bir juft qavslar va ularning orasida vergul bilan ajratilgan parametrlar ketma-ketligi

- va bir juft Jingalak kavslar va ularning orasida bir yoki undan ko'p bo'lgan JS-codelar

```javascript
// Print the name and value of each property of o.  Return undefined.
function printprops(o) {
    for(let p in o) {
        console.log(`${p}: ${o[p]}\n`);
    }
}

// Compute the distance between Cartesian points (x1,y1) and (x2,y2).
function distance(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx*dx + dy*dy);
}

// A recursive function (one that calls itself) that computes factorials
// Recall that x! is the product of x and all positive integers less than it.
function factorial(x) {
    if (x <= 1) return 1;
    return x * factorial(x-1);
}
```


**Function name ya'ni nomi o'zgaruvchi hisoblanadi va uning qiymati functionga teng**

Function `hoisted` hisoblanadi va u o'zi yaratilishidan oldin ishlatilishi mumkin. 


`distance()` va `factorial()` funksiyalari misol sifatida keltirlgan edi. 
Functionda hisoblangan qiymat `return` qilish orqali chaqiruvchiga javob qiymat qaytaradi, **return bu functionning tugashini bildiradi**

agar functionda `return` bo'lmasa yoki shunchaki `return;` sifatida berilsa qaytarilgan qiymat `undefined` hisoblanadi.

Masalan `printpros()` funcsiyasing vazifasi objectning `name` va `value` larini console-ga chiqarishdan iborat.

**Hechqanday qiymat qaytarilmasa shunchaki `return` ni ishlatmaslik mumkin.**

Function-larni `if, for` kabi blok-lar ichida yaratmagan maqul.

### Function Expressions

Function expressionlar huddi function declare qilsihga o'xshaydi leking.

```javascript
// This function expression defines a function that squares its argument.
// Note that we assign it to a variable
const square = function(x) { return x*x; };

// Function expressions can include names, which is useful for recursion.
const f = function fact(x) { if (x <= 1) return 1; else return x*fact(x-1); };
// OR const f = function (x) { if (x <= 1) return 1; else return x*f(x-1); };

// Function expressions can also be used as arguments to other functions:
[3,2,1].sort(function(a,b) { return a-b; });

// Function expressions are sometimes defined and immediately invoked:
let tensquared = (function(x) {return x*x;}(10));
```

Function Declaration o'zgaruvchi yaratadi lekin function expression variable yaratmaydi, bu vaziyatga bog'li, biz hohlasak function expressionni o'zgaruvchiga saqlashimiz mumkin yoki yo'q.

**Best practice `const` ishlatish**

---

```javascript
// Bunday qilish xato
function f() {}

const some_f = f // bu biz kuntgandek function expression emas;
```

### Arrow Functions

```javascript
const sum = (x, y) => { return x + y; };

// OR

const sum = (x, y) => x + y;

// OR

const polynomial = x => x*x + 2*x + 3;

// OR

const constFunc = () => 42;
```

Agar arrow-function objectni return qilishi kerak bo'lsa:

```javascript
const f = x => { return { value: x }; };  // Good: f() returns an object
const g = x => ({ value: x });            // Good: g() returns an object
const h = x => { value: x };              // Bad: h() returns nothing
const i = x => { v: x, w: x };            // Bad: Syntax Error
```


```javascript
// Make a copy of an array with null elements removed.
let filtered = [1,null,2,3].filter(x => x !== null); // filtered == [1,2,3]
// Square some numbers:
let squares = [1,2,3,4].map(x => x*x);               // squares == [1,4,9,16]
```


**Arrow Function oddiy Function declarationidan yana boshqa Juda ham muhum tarafi bilan ajralib turadi.**

Arrow functionda o'zining `context`ni yaratish o'rniga `this` keywordi ya'ni `context value`-ni o'zini o'rab turgan scopedan  oladi.

Ularda o'zining `prototype` bo'lmaydi.

### Nested Functions

Javascriptda function bir birining ichkarisida bo'lishi mumkin: 

```javascript
function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
```

**O'zini o'rab turgan function-ning paramtrlari ichkaridagi functionda ham ishlatilishi mumkin**

## Invoking Functions

JS-da functionlar 5 ta usul bilan chaqirilishi mumkin:

- As functions
- As methods
- As constructor
- Indirectly through their call() and apply() methods
- Implicitly, via JavaScript langauge features tha do not appear like normal function invocations

### Function Invocation

> Invocation Expression
```javascript
printprops({x: 1})
let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5)
let probability = factorial(5) / factorial(13);
```

Agar function property access expression bo'lsa ?. Bu holda unga method expression invocation deyiladi.

'use strict' yani strict modeda invocation context is undefinde. lekin strict mode bo'lamas this bu global objectga teng.

```javascript
// 'use strict'

const strict = (function() { console.log(this); return !this}())

console.log(strict)
```


**Recursive function stack haqida !!!**


### Method Invocation


---

 `get` and `set` ? Bu haqida tushuntirlsin.

 ### Property Getters and Setters

 _accesssor properties_: Getters and/or Setters

 ```javascript
 let o = {
     // An oridnary data property
     dataProp: value,

     // An Accessor property defined as a pair of functions.
     get accessorProp() { return this.dataProp; }
     set accessorProp(value) { this.dataProp = value; }
 }
 ```

  ```javascript
let  p  = {
    // x and y are regular rea-write data properties.
    x: 1.0,
    y: 1.0,

    // r is a read-write accessor property with getter and setter.
    // Don't forget to put a comma after accessor methods.
    get r() { return Math.hypot(this.x, this.y); },
    set r(newValue) {
        let oldvalue = Math.hypot(this.x, this.y);
        let ratio = newValue/oldvalue;
        this.x = this.x * ratio;
        this.y = this.y * ratio;
    },
    // theta is read-only accessor property with getter only.
    get theta() { return Math.atan2(this.y, this.x); }
}

p.r     // => Math.SQRT2
p.theta // => Math.PI / 2
 ```

**_Accessor Properties are Inherited_**

```javascript
let q = Object.create(p); // A new object that inherits getters and setters
q.x = 3;  q.y = 4; // Creates q's own data properties
q.r // => 5: the inherited accessor properties work
q.theta // => Math.atan2(4, 3)
```

Accessor propertylarni ishlatilishiga yana bir sabab propertyga qiymatni validatsiya orqali berish bo'ladi.

```javascript
// This object generates strictly increasing serial numbers
const serailnum = {
    // This data property holds the next serail number.
    // The _ in the name hints that is for internal use only.
    _n: 0,

    // Return the current value and increase it
    get next() { retrun this._n++ },

    // Set a new value of n, but only if it is larger than current 
    set next(n) {
        if(n > this._n) this._n = n;
        else throw new Error("Serial number can only be set to a larger value")
    }
}

serailnum.next = 10; // Set the starting serail number
serialnum.next // => 10
serailnum.next // => 11: different value each time we get next

```

---

**_method_** bu JavaScript Objectidagi qiymati function-ga teng bo'lgan propertyga aytiladi.

yani masalan agar bizda `o` objecti bor deylik va uning `m` propertysi bo'ladigan bo'lsa uning qiymati `0.m = f` ko'rinishida bo'lishi mumkin.

va method invocation quydagicha bo'lishi mumkin:
```javascript
o.m()

// OR if we have params
o.m(x, y)
```

Bunaqa method chaqirilganda **context** `o`-objectning o'zi bo'ladi, va bu method/function `this` keywordi orqali gera bo'ladi.

```javascript
let calculator = { // An object literal
    operand1: 1,
    operator2: 1,
    add() { // We're using method shorthand syntax for this function
        // Note the use of the this keyword to refer to containing object.
        this.result = this.operand1 + this.operand2

    }
}

calculator.add(); // A method invocation to compute 1+1.
calculator.result // => 2
```

Method invocation `[]` - kavslari orqali ham qilinishi mumkin:
```javascript
o["m"](x, y) // Another way to write o.m(x, y)
a[0](z) // Also a method invocation (assuming a[0] is a function).
```

Methodlar va this keywordi OOP programming uchun markaziy tushuncha hisoblanadi.

```javascript
rect.setSize(width, height)
setRectSize(rect, width, height)
```

**Bu ikkalasi bir hil ish qilishi mumkin lekin kod-ga qarasak birinchi qator ifodasi ikkinchi qatorga qaraganda ancha tushunarliroq yani bizning asosiy ustida ish olib borayotgan obyekt bu `rect`**


`this` kalit so'zi boshqa variable-larga o'xshamaydi JS uning qiymatini o'zgartirishga yo'l qo'ymaydi. Va this-ning scope variable-o'zgaruvchilarnikidek bo'lmaydi. Ichma-ich yozilgan functionlar this-kalit so'zini inherit/meros qilib olmaydi **lekin arrow-functiondan boshqa**

```javascript
let  o = { // An object o.
    m: function() {         // Method m of the object.
        let self = this;    // Save the "this" value in a variable
        this === o          // => true: "this" is the object o.
        f();

        function f() {      // A nested function f
            this === o      // => false: "this" is global or undefined
            self === o      // => true: self is the outer "this" value
        }

        const f2 = () => {
            this === o      // => true
            self === o      // => true: self is the outer "this" value
        }

        f2();
    }

}

o.m()
```

### Constructor Invocation

Agar function yoki method `new` kalit so'zi orqali ishlatilsa/chaqirilsa bu **Consotructor invocation** deyiladi.

Constructor Invocation oddiy function yoki method invocation lardan
- argumentlar bilan ishlashd
- chaqirilgan argumentnig context- da
- return qiymatida
farq qiladi.

Agar constructor invocation o'zida kavslar orasida vergul bilan ajratilgan argumentlarga ega bo'lsa u oddiy function yoki methodga argument berilgandek bo'laveradi. 

```javascript
o = new Object()
o = new Object // bu yerda kavslar tushirilib qoldirilgan va ular bir-xil ishlaydi.
```
Constructor function yoki method odatda `return` kalit so'zini ishlatmaydi. Ular odatda yangi obyekt yaratadi va shu obyektni function/method oxiriga yetganida automatik ravishda yuboriladi. Agar return kalit so'zi obyekt qaytarish uchun ishlatilsa, constructor invocation ifodasinging value-si o'sha obyekt bo'ladi.

Agar constructor hechnima qaytarmas yoki primitive turdagi ma'lumotni qaytarsa ular hisobga olinmaydi va yangi obyekt value sifatida ishlatiladi. 

### Indirect Invocation

Javascript function-lari obyektlardur, va boshqa JS obyektlaridek ularning ham methodlari bor. `call()` va `apply()`

Bu ikki methodlar ham biz o'zimiz this keyvord qanday qiymatga ega bo'lishimi hal qilishmiz mumkin, hattoki bu function ma'lum bir obyektga tegishli bo'lmasa ham.


## Function Arguments and Parameters

### Optional Parameters and Defults

```javascript
// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a) {
    if (a === undefined) a = [];  // If undefined, use a new array
    for(let property in o) a.push(property);
    return a;
}

// getPropertyNames() can be invoked with one or two arguments:
let o = {x: 1}, p = {y: 2, z: 3};  // Two objects for testing
let a = getPropertyNames(o); // a == ["x"]; get o's properties in a new array
getPropertyNames(p, a);      // a == ["x","y","z"]; add p's properties to it
```

```javascript
// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a = []) {
    for(let property in o) a.push(property);
    return a;
}
```


```javascript
// This function returns an object representing a rectangle's dimensions.
// If only width is supplied, make it twice as high as it is wide.
const rectangle = (width, height=width*2) => ({width, height});
rectangle(1)  // => { width: 1, height: 2 }
```

### Rest Parameters and Variable-Length Argument Lists

```javascript
function max(first=-Infinity, ...rest) {
    let maxValue = first; // Start by assuming the first arg is biggest
    // Then loop through the rest of the arguments, looking for bigger
    for(let n of rest) {
        if (n > maxValue) {
            maxValue = n;
        }
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // => 1000
```


### The Arguments Object

```javascript
function max(x) {
    let maxValue = -Infinity;
    // Loop through the arguments, looking for, and remembering, the biggest.
    for(let i = 0; i < arguments.length; i++) {
        if (arguments[i] > maxValue) maxValue = arguments[i];
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // => 1000
```


### The Spread Operator for Function Calls

```javascript
let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers)  // => -1
```

```javascript
// This function takes a function and returns a wrapped version
function timed(f) {
    return function(...args) {  // Collect args into a rest parameter array
        console.log(`Entering function ${f.name}`);
        let startTime = Date.now();
        try {
            // Pass all of our arguments to the wrapped function
            return f(...args);  // Spread the args back out again
        }
        finally {
            // Before we return the wrapped return value, print elapsed time.
            console.log(`Exiting ${f.name} after ${Date.now()-startTime}ms`);
        }
    };
}

// Compute the sum of the numbers between 1 and n by brute force
function benchmark(n) {
    let sum = 0;
    for(let i = 1; i <= n; i++) sum += i;
    return sum;
}

// Now invoke the timed version of that test function
timed(benchmark)(1000000) // => 500000500000; this is the sum of the numbers
```


### Destructuring Function Arguments into Parameters

```javascript
function vectorAdd(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorAdd([1,2], [3,4])  // => [4,6]
```

```javascript
function vectorAdd([x1,y1], [x2,y2]) { // Unpack 2 arguments into 4 parameters
    return [x1 + x2, y1 + y2];
}
vectorAdd([1,2], [3,4])  // => [4,6]
```

```javascript
// Multiply the vector {x,y} by a scalar value
function vectorMultiply({x, y}, scalar) {
    return { x: x*scalar, y: y*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // => {x: 2, y: 4}
```

```javascript
function vectorAdd(
    {x: x1, y: y1}, // Unpack 1st object into x1 and y1 params
    {x: x2, y: y2}  // Unpack 2nd object into x2 and y2 params
)
{
    return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({x: 1, y: 2}, {x: 3, y: 4})  // => {x: 4, y: 6}
```
```javascript
// Multiply the vector {x,y} or {x,y,z} by a scalar value
function vectorMultiply({x, y, z=0}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // => {x: 2, y: 4, z: 0}
```

```javascript
function arraycopy({from, to=from, n=from.length, fromIndex=0, toIndex=0}) {
    let valuesToCopy = from.slice(fromIndex, fromIndex + n);
    to.splice(toIndex, 0, ...valuesToCopy);
    return to;
}
let a = [1,2,3,4,5], b = [9,8,7,6,5];
arraycopy({from: a, n: 3, to: b, toIndex: 4}) // => [9,8,7,6,1,2,3,5]

```

```javascript
// This function expects an array argument. The first two elements of that
// array are unpacked into the x and y parameters. Any remaining elements
// are stored in the coords array. And any arguments after the first array
// are packed into the rest array.
function f([x, y, ...coords], ...rest) {
    return [x+y, ...rest, ...coords];  // Note: spread operator here
}
f([1, 2, 3, 4], 5, 6)   // => [3, 5, 6, 3, 4]
```

```javascript
// Multiply the vector {x,y} or {x,y,z} by a scalar value, retain other props
function vectorMultiply({x, y, z=0, ...props}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar, ...props };
}
vectorMultiply({x: 1, y: 2, w: -1}, 2)  // => {x: 2, y: 4, z: 0, w: -1}
```

### Argument Types

```javascript
// Return the sum of the elements an iterable object a.
// The elements of a must all be numbers.
function sum(a) {
    let total = 0;
    for(let element of a) { // Throws TypeError if a is not iterable
        if (typeof element !== "number") {
            throw new TypeError("sum(): elements must be numbers");
        }
        total += element;
    }
    return total;
}
sum([1,2,3])    // => 6
sum(1, 2, 3);   // !TypeError: 1 is not iterable
sum([1,2,"3"]); // !TypeError: element 2 is not a number
```


## Functions as Values

```javascript
function square(x) { return x*x; }



 /// Va

let s = square;  // Now s refers to the same function that square does
square(4)        // => 16
s(4)             // => 16



///

// We define some simple functions here
function add(x,y) { return x + y; }
function subtract(x,y) { return x - y; }
function multiply(x,y) { return x * y; }
function divide(x,y) { return x / y; }

// Here's a function that takes one of the preceding functions
// as an argument and invokes it on two operands
function operate(operator, operand1, operand2) {
    return operator(operand1, operand2);
}

// We could invoke this function like this to compute the value (2+3) + (4*5):
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// For the sake of the example, we implement the simple functions again,
// this time within an object literal;
const operators = {
    add:      (x,y) => x+y,
    subtract: (x,y) => x-y,
    multiply: (x,y) => x*y,
    divide:   (x,y) => x/y,
    pow:      Math.pow  // This works for predefined functions too
};

// This function takes the name of an operator, looks up that operator
// in the object, and then invokes it on the supplied operands. Note
// the syntax used to invoke the operator function.
function operate2(operation, operand1, operand2) {
    if (typeof operators[operation] === "function") {
        return operators[operation](operand1, operand2);
    }
    else throw "unknown operator";
}

operate2("add", "hello", operate2("add", " ", "world")) // => "hello world"
operate2("pow", 10, 2)  // => 100
```

### Defining Your Own Function Properties

```javascript
// Initialize the counter property of the function object.
// Function declarations are hoisted so we really can
// do this assignment before the function declaration.
uniqueInteger.counter = 0;

// This function returns a different integer each time it is called.
// It uses a property of itself to remember the next value to be returned.
function uniqueInteger() {
    return uniqueInteger.counter++;  // Return and increment counter property
}
uniqueInteger()  // => 0
uniqueInteger()  // => 1
```


```javascript
// Compute factorials and cache results as properties of the function itself.
function factorial(n) {
    if (Number.isInteger(n) && n > 0) {           // Positive integers only
        if (!(n in factorial)) {                  // If no cached result
            factorial[n] = n * factorial(n-1);    // Compute and cache it
        }
        return factorial[n];                      // Return the cached result
    } else {
        return NaN;                               // If input was bad
    }
}
factorial[1] = 1;  // Initialize the cache to hold this base case.
factorial(6)  // => 720
factorial[5]  // => 120; the call above caches this value
```


## Functions as Namespaces


```javascript
function chunkNamespace() {
    // Chunk of code goes here
    // Any variables defined in the chunk are local to this function
    // instead of cluttering up the global namespace.
}
chunkNamespace();  // But don't forget to invoke the function!
```

```javascript
(function() {  // chunkNamespace() function rewritten as an unnamed expression.
    // Chunk of code goes here
}());          // End the function literal and invoke it now.
```